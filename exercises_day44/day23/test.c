#define _CRT_SECURE_NO_WARNINGS 1

/*
试题 算法训练 K好数
资源限制
时间限制：1.0s   内存限制：256.0MB
问题描述
如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。由于这个数目很大，请你输出它对1000000007取模后的值。

输入格式
输入包含两个正整数，K和L。

输出格式
输出一个整数，表示答案对1000000007取模后的值。
样例输入
4 2
样例输出
7
*/

/*
思路分析： 该题提示为动态分析问题
    1.我们可以把k进制数的每一个开头数字固定 然后对其他位可以放的数字依次做讨论
	例如k = 4   开头数字可以取0  1  2  3   分别对这四种情况的其他位数字依次做讨论

    2.当位数即L = 1时  任何K进制数都只有一个方案 即自己本身
	例如K = 4  只能取 0 1 2 3  所以结果位1+1+1+1 = 0

	3.列出k = 4  L = 3时的表格 
	第一位：  0             1              2                3      
	第二位： 00 02         11 13          20 22            30 31
	         03                                            33
	第三位：           1：111 113       0：200 202 203  0：300 302 303
	                   3：133 131 133   2：220 222      1：311 313 
			                                            3：330 331 333
	4.由该表格可以找出规律：
	   第i位寻找到的不相邻数字 都是加上第i-1行不相邻数字的种类个数
	   例如当以1为首数字 在第二位上寻找到1满足条件 ret1+=1，当找到3时ret1+=1  (ret为结果)
	   在第三位找到1时 ret+=ret1 当找到3满足条件时 ret+=ret3  
	   由于该表格可以得出 ret1 = 2  ret3 = 3  所以ret =  5  所以在开头数字位1的条件下 三位数字互不相邻的情况有5种

*/
//代码如下
#include<stdio.h>
unsigned long long ret[110][110] = { 0 };
#define MOD  1000000007
int main(){
	int k = 0, l = 0, i = 0, j = 0, x = 0;
	unsigned long long ret1 = 0;
	scanf("%d%d", &k, &l);
	if (k != 1 && l == 1){
		printf("%d", k);
		return 0;
	}
	for (i = 0; i < k; i++){ //由于上述分析第二点 当只有一位时 以各种数字开头的时候，都只有一种结果 所以将第一位全部
		ret[0][i] = 1;       //初始化位1
	}

	for (i = 1; i < l; i++){//控制位数 由于第一位已经初始化为1 所以从第二位开始
		for (j = 0; j < k; j++){ //控制此时是以哪个数字开头的情况
			for (x = 0; x < k; x++){//去遍历判断每一个数字是否符合条件
				if (x != j + 1 && x != j - 1){//符合条件
					ret[i][j] += ret[i - 1][x];
					ret[i][j] %= MOD;
				}
			}
		}
	}

	//输出结果
	for (j = 1;  j< k; j++){ //因为当以0开头时不满足l位数
		ret1 += ret[l-1][j];
		ret1 %= MOD;
	}
	printf("%llu", ret1);
	return 0;
}